第二周算法笔记
哈希表 Hash Table
哈希表也叫散列表，是根据key value而直接访问的数据结构

通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度

这个映射函数叫散列函数，存放记录的数组叫哈希表或散列表

1. 哈希函数 O(1)

要存放一个"lies"，lies传给哈希函数，它就会返回一个下标，这里返回一个9

这里如果再来一个字符串，传给哈希函数，得到的值与429一样，经过哈希函数后返回的下标与lies一样，这就称为哈希碰撞

解决方法：可以在9这个位置存放不止一个数据，拉出来一个链表，存放多个数，即拉链式解决数据冲突，如果链表很长，时间复杂度就退化为o(n)

2. 哈希碰撞

3. 代码
在实际中使用哈希表的话我们抽象为Map和Set

树

单链表的next指针，指向多个结点就变成了一棵树。

根节点：A，然后分为左子树与右子树

B和C为A的儿子结点

D为H和I的父亲节点，F和G时兄弟结点

1. 二叉树 Binary Tree

一个结点的儿子结点只有两个：左儿子和右儿子

树和图的最大区别就是看有没有环


2. 树的代码定义

3. 二叉树的遍历
​ 这里的序可以理解为当前结点

前序：当前结点—左—右
中序：左—当前结点—右
后序：左—右—当前结点
4. 二叉搜索树
二叉搜索树：也叫二叉搜索排序树、有序二叉树、排序二叉树（Sorted Binary Tree）,指的是一棵空树或者具有下列性质的二叉树

左子树上所有结点的值均小于它的根结点的值
右子树上所有结点的值均大于它的根结点的值
以此类推：左、右子树也分别为二叉查找树
中序遍历：升序排列

常见操作：o(logn) 加速

查询：类似于二分搜索
插入：查找这个结点，找到就计数加一，没有则在最后到达的位置添加
删除：如果是叶子结点直接删除，如果不是，一般取该结点的右子树里面最小的结点替换掉该结点即可
树的面试题解法一般都是递归

堆
1. 堆 Heap
堆：可以迅速找到一堆数中的最大或者最小值的数据结构

根节点最大的堆叫做大顶堆，根节点最小的堆叫做小顶堆

操作：

find-max: o(1)

delete-max: o(logn) insert(create): o(logn)或者o(1)—>斐波那契堆

2. 二叉堆性质
通过完全二叉树实现，不是二叉搜素树

完全二叉树：指的是根结点以及每一级结点都是满的，除了最下面的一层叶子结点可能不满以外

二叉堆（大顶堆）满足以下性质：

是一棵完全树
树中任意节点的值总是>=其子节点的值


3. 操作思路
查询：直接返回根节点 o(1)

插入：o(logn)

新元素一律先插入到堆的尾部 —>即一维数组的尾部
依次向上调整整个堆的结构（一直到根） —>HeapifyUp 向上调整
调整方法就是如果大于父亲节点就与父亲节点进行替换


​ 首先将85添加到尾部，即40的左儿子位置处，然后向上调整，若85大于它的父亲节点，那么就与父亲节点交换，直到走到根节点

​ 树的深度就是它的最大的时间复杂度，也就是o(logn)—>因为它最坏情况也仅仅是一直往上走，直到和根节点进行交换

删除最大元素：o(logn)

将堆尾元素替换到顶部
依次从根部向下调整整个堆的结构，直到堆尾即可—>HeapifyDown
如何调整呢？就是与子节点比较，选取较大的儿子，然后交换

图
1. 属性
2. 表示方法
邻接矩阵与邻接表

3. 常用算法
DFS
BFS