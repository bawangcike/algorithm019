一、数组Array
Array底层硬件实现
在申请一个数组时计算机会在内存空间中开辟一段连续的地址，每个地址都可以通过内存管理器进行访问，访问第一个元素或中间的任何一个元素时间复杂度都是一样的都为O(1)。它可以进行随机地访问任何一个元素，所有它的访问时间非常快这是数组的特性之一。

Array增加删除元素
在对一个数组的中间位置增加一个元素时，需要把此下标以及该下标之后的元素向后移动一个位置。因此数组的插入操作的时间复杂度为O(n)。
删除一个数组的某个元素时，和数组添加元素类似，先把此元素删除，再把此元素之后的元素向前移动。

数组的各个操作时间复杂度为

操作	时间复杂度
头添加	O(1)
尾添加	O(1)
其他位置添加	O(n)
删除	O(n)
查询	O(1)

二、链表LinkList
访问链表中的元素
访问头结点和尾节点的时间复杂度都为O(1)，访问其他节点则为O(n)

链表增加新节点
先创建一个新节点，插入位置的前一个节点的指针指向新节点，新节点的指针指向插入位置的后一个节点，时间复杂度为O(1)

链表删除节点
将删除节点的前一个节点的指针指向要删除节点的后一个节点，时间复杂度为O(1)

链表的各个操作时间复杂度为

操作	时间复杂度
头插入	O(1)
尾插入	O(1)
其他位置插入	O(1)
删除	O(1)
查询	O(n)

三、跳表Skip List

注意：只能用于元素有序的情况。
所以，跳表（skip list）对标的是平衡树（AVL Tree）和二分查找，
是一种 插入/删除/搜索 都是 O(log n) 的数据结构。1989 年出现。
它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此
在一些热门的项目里用来替代平衡树，如 Redis、LevelDB 等。

跳表改善了链表查询的效率
增加一级索引，在原始链表中，next指向的是下一个节点，在一级索引中指向的是next+1。在原始链表中，每次移动的步长为1，在一级索引中移动的步长为2。

增加二级索引，在一级索引的基础上，二级索引的速度是一级索引的两倍，也就是移动步长为4。

综上所述，可以对一个链表增加多级索引，即增加log2n个索引

跳表时间复杂度分析

在使用跳表的情况下，由于元素的增删，索引所跨越的节点个数会有变化，在增加和删除元素时会更新索引，所以维护成本较高。与原始列表相比增加和删除的时间复杂度变为logn

四、栈Stack
特性：先进后出、后进先出
时间复杂度：添加和删除元素O(1)，查询某个元素O(n)

五、队列Queue
特性：先进先出、后进后出
时间复杂度：添加和删除元素O(1)，查询某个元素O(n)

六、双端队列Deque
双端队列为栈和队列的结合体。它可以往队列前端添加或移除元素，也可以往队列后端添加或移除元素
时间复杂度：插入和删除元素O(1)，查询某个元素O(n)

七、优先队列PriorityQueue
特性：和栈与队列不同，不在是先入后出或先入先出，而是按照元素优先级出
时间复杂度：插入操作为O(1)，取出操作为O(logn)【按照元素优先级取出】
优先队列底层具体实现的数据结构较为多样和复杂，可以使用heap堆、bst二叉搜索树、treap树堆来实现